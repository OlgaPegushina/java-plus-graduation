# Explore With Me (Микросервисная версия)

**Explore With Me** — это бэкенд-сервис для афиши событий, где пользователи могут находить интересные мероприятия, создавать свои собственные и участвовать в них. Проект реализован на основе современной микросервисной архитектуры с использованием **Spring Cloud**.

---

## Архитектура проекта

Проект построен на принципах микросервисной архитектуры для обеспечения гибкости, масштабируемости и отказоустойчивости. Ключевые компоненты экосистемы Spring Cloud играют центральную роль во взаимодействии сервисов.

#### Компоненты инфраструктуры

*   **Config Server** (`config-server`): Централизованное хранилище конфигураций для всех микросервисов. Позволяет изменять настройки приложений без их перезапуска.
*   **Discovery Server (Eureka)** (`discovery-server`): Сервис обнаружения. Каждый микросервис при запуске регистрируется в Eureka, что позволяет им динамически находить друг друга по имени.
*   **API Gateway** (`gateway-server`): Единая точка входа для всех внешних запросов. Отвечает за маршрутизацию, а также может выполнять задачи аутентификации, логирования и ограничения скорости запросов.

#### Бизнес-микросервисы

*   **Event Service** (`event-service`): Основной сервис, отвечающий за всю бизнес-логику, связанную с событиями, категориями и подборками.
*   **User Service** (`user-service`): Отвечает за управление пользователями (создание, получение данных, обновление, удаление).
*   **Request Service** (`request-service`): Отвечает за управление запросами на участие в событиях (создание, подтверждение, отклонение).
*   **Comment Service** (`comment-service`): Сервис для управления комментариями к событиям.
*   **Statistics Service** (`stats-server`): Сервис для сбора и предоставления статистики по просмотрам событий.

#### Хранение данных (Database per Service)

*Каждый бизнес-микросервис имеет свою собственную, изолированную базу данных* **PostgreSQL**. Этот подход является ключевым для микросервисной архитектуры, так как обеспечивает слабую связанность (*loose coupling*) между сервисами. Один сервис не может напрямую получить доступ к таблицам другого. Все взаимодействие происходит исключительно через API.

#### Схема взаимодействия

Взаимодействие между сервисами происходит через REST API. Для межсервисной коммуникации используется декларативный клиент **Feign**, который интегрирован с Eureka для динамического обнаружения нужного сервиса.

```text
       Клиент (Postman/Frontend)
                  |
                  v
+-----------------------------------+
|     API Gateway (Spring Cloud)    |
+-----------------------------------+
       ^          |
       |          | (1) Внешний запрос
       |          v
       |  +--------------------------------+
       |  | Event Service                  |------(3) Feign-----> User Service
       |  |                                |------(3) Feign-----> Request Service
       |  +--------------------------------+
       |
+-----------------------------------+
| Discovery Server (Eureka)         |
| (Регистрация и обнаружение)        |<----(2) Все сервисы регистрируются здесь
+-----------------------------------+
                  ^
                  |
+-----------------------------------+
|     Config Server (Spring Cloud)    |
| (Централизованная конфигурация)    |<----(0) Все сервисы получают настройки отсюда
+-----------------------------------+
```
1.  **Внешний запрос** приходит на API Gateway.
2.  Gateway, используя Eureka, находит нужный сервис (например, `event-service`) и перенаправляет запрос.
3.  Если `event-service` для выполнения задачи нужны данные из другого сервиса (например, имя пользователя из `user-service`), он использует **Feign Client**, который через Eureka находит `user-service` и отправляет ему внутренний запрос.

---

## Технологический стек

*   **Язык**: Java 21
*   **Фреймворк**: Spring Boot 3.x
*   **Spring Cloud**:
    *   *Spring Cloud Gateway*: для API-шлюза.
    *   *Spring Cloud Netflix Eureka*: для Service Discovery.
    *   *Spring Cloud Config Server*: для централизованной конфигурации.
    *   *Spring Cloud OpenFeign*: для декларативных REST-клиентов.
*   **База данных**: PostgreSQL (схема "Database per Service").
*   **ORM**: Spring Data JPA, Hibernate.
*   **Сборка проекта**: Maven.
*   **Контейнеризация**: Docker, Docker Compose.
*   **Вспомогательные библиотеки**:
    *   `Lombok` (для сокращения шаблонного кода).
    *   `QueryDSL` (для типобезопасных запросов).
    *   `MapStruct` (для маппинга DTO).

---

## Основные возможности (API)
Проект предоставляет три типа эндпоинтов, доступ к которым осуществляется через API Gateway

#### Публичные (Public API)
*   Просмотр событий с фильтрацией и сортировкой.
*   Просмотр категорий и подборок событий.
*   Получение комментариев к событию.

#### Приватные (Private API)
*   Создание, редактирование и просмотр своих событий.
*   Отправка, просмотр и отмена своих запросов на участие.
*   Управление статусами заявок на участие в своих событиях.
*   Добавление, редактирование и удаление своих комментариев.

#### Админские (Admin API)
*   Управление пользователями (создание, просмотр, обновление, удаление).
*   Управление категориями, событиями и подборками.
*   Модерация событий и комментариев.

---

## Как запустить проект локально
Для запуска проекта вам потребуются установленные **Java 21**, **Maven** и **Docker**.

### 1. Сборка проекта
Перед первым запуском необходимо собрать все модули проекта с помощью Maven.

```bash
mvn clean install -DskipTests
```
### 2. Запуск с помощью Docker Compose
Самый простой способ поднять всё окружение — использовать Docker Compose.

```bash
docker-compose up --build
```
Эта команда последовательно запустит все контейнеры в правильном порядке:

1.  Контейнеры с базами данных PostgreSQL для каждого сервиса.
2.  `config-server`
3.  `discovery-server`
4.  Бизнес-сервисы (`event-service`, `user-service`, `request-service`, `comment-service`, `stats-server`).
5.  `gateway-server`

После запуска всех контейнеров:

*   **Панель Eureka** будет доступна по адресу: `http://localhost:8761`
*   **Проект** будет доступен через шлюз по адресу: `http://localhost:8080`

### 3. Остановка проекта
Чтобы остановить все запущенные контейнеры, нажмите `Ctrl+C` в терминале, где был запущен `docker-compose`, а затем выполните:

```bash
docker-compose down
```

---

## Пример использования API
После запуска вы можете отправлять запросы к сервису через Gateway.

**Пример: Получение полной информации о событии**

1.  Клиент отправляет запрос на Gateway: `GET /events/1`.
2.  Gateway перенаправляет запрос на **Event Service**.
3.  Event Service находит в своей базе данных событие с `id=1`. В этом событии есть поле `initiatorId`.
4.  Чтобы обогатить ответ полными данными об инициаторе, **Event Service** через свой Feign-клиент отправляет внутренний запрос `GET /admin/users/123` (где `123` - это `initiatorId`) к **User Service**.
5.  User Service отвечает данными пользователя.
6.  Event Service собирает полную DTO события, включая данные об инициаторе, и возвращает клиенту.

---

## Автор
*   **Имя:** Ольга
*   **Email:** pegushina.shine@yandex.ru
*   **Telegram:** @TheSunOfSpring
